# SRT校正與重試機制
## SRT 校正與生成機制

### 第一層：時間戳格式校正 (`parse_time_v10`)

這是最基礎的校正層，專門處理單一時間戳字串的各種不規範格式。無論後續邏輯如何，所有時間戳都會先經過此函式進行「標準化」。

- **觸發條件**: 任何時間戳在被解析為時間物件前。
- 校正機制:
  1. **統一分隔符**: 自動將毫秒前的分隔符 `.` 或 `:` 替換為標準的 `,`。
  2. 處理缺漏:
     - `mm:ss,xxx` 格式會自動補全為 `00:mm:ss,xxx`。
     - `ss,xxx` 格式會自動補全為 `00:00:ss,xxx`。
  3. **處理冒號毫秒**: 修正 `hh:mm:ss:xxx` 這種非標準格式為 `hh:mm:ss,xxx`。
  4. 補零:
     - 小時、分鐘、秒數若不足兩位數，會自動在左側補 `0`。
     - 毫秒若不足三位數，會自動在**左側**補 `0` (例如 `99` 會變成 `099`)。
  5. 範圍校正:
     - 若秒數 `ss` >= 60，會被校正為 `59` 並記錄警告。
     - 若分鐘數 `mm` >= 60，會被校正為 `59` 並記錄警告。
  6. 格式過濾:
     - 會主動攔截並拒絕包含影格(frame)的四段式時間戳 (如 `hh:mm:ss:ff,xxx`)，因為此格式無法安全轉換。
     - 會攔截包含超過兩個冒號的無效時間格式。

### 第二層：SRT 結構與內容解析 (`format_srt_from_text_v16`)

這一層負責從模型回傳的原始文本中，穩健地解析出一個個的字幕塊，即使格式有些混亂。

- **觸發條件**: 每次從 AI 模型獲取到回應文本後。
- 解析機制:
  1. **逐行解析**: 採用逐行讀取的方式，依序尋找「數字序號」 -> 「時間戳行」 -> 「字幕文本」，比傳統的 `\n\n` 分割更能抵抗缺少空行的格式錯誤。
  2. **空文本容忍**: 即使某個字幕塊的文本內容為空，只要其時間戳有效，依然會將其視為一個有效的「靜音塊」進行處理，確保時間軸的連續性。
  3. **解析失敗拋出異常**: 如果從頭到尾都無法解析出任何一個有效的字幕塊，會拋出 `SRTContentParseError` 異常，此異常會被上層的重試機制捕獲。

### 第三層：SRT 邏輯性錯誤校正 (`format_srt_from_text_v16`)

在成功解析出字幕塊後，這一層會檢查並修正時間軸上的邏輯錯誤。

- **觸發條件**: 在 `format_srt_from_text_v16` 函式內部，當字幕塊的時間戳出現邏輯問題時觸發。
- 校正機制:
  1. **嚴重修正計數**: 系統會計算「嚴重修正」的次數，若超過設定的閾值 (`correction_threshold`，預設為 6)，則會觸發**重試機制**。
  2. 被視為「嚴重修正」的錯誤:
     - **無法解析/時間倒流**: 時間戳格式無法被 `parse_time_v10` 解析，或結束時間早於開始時間。
     - **時間軸重疊**: 當前字幕塊的開始時間，早於前一個已校正字幕塊的結束時間（有 `overlap_tolerance` 容忍值，預設 0.5 秒）。
     - **持續時間異常過長**: 單一字幕的持續時間超過 `MAX_DURATION` (預設 18 秒)。
  3. 智慧校正策略:
     - **向前探測**: 當發生上述嚴重錯誤時，程式會向前探測下一個「格式正確」的字幕塊，並取得其開始時間 (`next_good_start_td`)。
     - **智慧置中/安全後貼**: 如果與「下一個正確字幕塊」且「當前錯誤塊與下個正確塊的時間間隔在合理範圍內(`MAX_REASONABLE_GAP`，預設30秒)」，會嘗試將當前錯誤的字幕塊「智慧地」安插在這段空白時間的中間或末尾。
  
       - **策略分歧 - 根據靜音時長決定**：
         - 安全後貼 (Safe Post-pending)
         
           1. 如果錯誤塊與下個正確塊之間的「靜音時長」過長(預設 > 10秒)，程式會認為這是一段很長的靜音，AI 可能是在靜音中產生了幻覺字幕。為了安全起見，它會採取保守的「後貼」策略，將這個錯誤字幕緊貼在下一個正確字幕的前面。
         
              - `結束時間 = 下個正確塊的開始時間 - 200毫秒`
              - `開始時間 = 新的結束時間 - 字幕安全時長`
           2. 智慧置中 (Smart Centering): 如果兩者間的「靜音時長」在正常範圍內(預設 <= 10秒)，程式會認為這只是一般的語句間隔。它會將這個錯誤字幕塊放置在這段空白時間的正中間，以達到最自然的視覺效果。
         
              - `開始時間 = 上個正確塊的結束時間 + (剩餘空白時間 / 2)`
         - `結束時間 = 新的開始時間 + 字幕安全時長`
     - **標準向前修正**: 「智慧型」策略失敗時的備用策略。如果探測不到下一個可用時間點，或間隔過長 (預設 > 30秒)，則會採用保守策略，將錯誤的字幕塊緊跟在前一個正確字幕塊的後面（加上100毫秒的緩衝）。
       - `開始時間 = 上個正確塊的結束時間 + 100毫秒`
       - `結束時間 = 新的開始時間 + 字幕安全時長`
  4. **邊界校正**: 在每一次循環的最後，都會檢查當前字幕塊的結束時間。確保字幕的結束時間不會超過音訊分塊的總長度。
     - 程式會強制將該字幕的 `結束時間` 修改為 `音訊分塊的總時長`。同時，為了防止因截斷導致「開始時間比結束時間還晚」的狀況，程式會再做一次檢查，確保至少有1秒的顯示時間。

---

## 重試與中止機制

### 重試機制 (`transcribe_audio`)

單一音訊區塊重做。

- 觸發條件:

  1. **API 伺服器錯誤**: 收到 Google API 的 5xx (伺服器錯誤) 或 429 (資源耗盡/速率限制) 回應。
  2. **API 回應為空**: 模型回傳的 `response.text` 為空字串 (`EmptyResponseError`)。
  3. **SRT 解析完全失敗**: `format_srt_from_text_v16` 未能從回應中解析出任何有效的字幕塊 (`SRTContentParseError`)。
  4. **嚴重修正次數超標**: `format_srt_from_text_v16` 回報的「嚴重修正」次數超過 `correction_threshold` 閾值。
  5. **最終結構驗證失敗**: 校正後的 SRT 內容中，序列號的總數與時間戳 (-->) 的數量的總數不匹配。
  
- 重試策略:

  - 採用「**指數退避 + 全抖動 **」策略。
  - 每次重試的等待時間會在一個動態增長的範圍內隨機選取，例如第一次在 0-65 秒間隨機等待，第二次在 0-130 秒間，以此類推。**(這段要修改!)**
  - 最大重試次數由 `--max_retries` 參數控制 (預設 3 次)。

### 流程中止機制 (`run_transcription_task`)

這是為了防止在遇到持續性問題（如 API 故障或 Prompt 問題）時，程式無限重試並浪費資源。

- 觸發條件

  - 當多個併發的轉錄任務**連續**返回「API 回應為空」或「SRT 解析完全失敗」的錯誤，且累計次數達到 `empty_abort_threshold` 閾值時 (預設為 5 次)。

- 處理機制:

  - 一旦觸發，整個轉錄流程會被**立即強制中止**，並拋出致命錯誤，終止程式。
- 任何一次成功的轉錄都會將此連續計數器歸零。

## 其他相關機制

- **局部轉錄時間軸校正 (`run_partial_transcription_task`)**:
  - 這是一個獨立的任務流程。在對指定時間區段（例如從 00:05:00 到 00:06:00）進行轉錄後，由於產生的 SRT 時間軸是從 0 開始的，此函式會自動將所有時間戳加上 `00:05:00,000` 這個起始偏移量，確保其與原始音訊的時間軸對齊。
- **結尾空白警告 (`transcribe_audio`)**:
  - 在每個區塊轉錄成功後，系統會檢查最後一句字幕的結束時間與整個音訊區塊的結尾之間是否存在過長的「靜音」。
  - 如果此空白時間超過 `truncation_threshold` (預設 60 秒)，系統會記錄一條**警告日誌**，提醒使用者這裡的字幕可能被意外截斷。
  - **注意**: 這**不會**觸發重試，僅作為一個供人工檢查的提示。
- **速率限制 (`MinuteRateLimiter`)**:
  - 這是一個跨執行緒共用的限速器，透過 `--rpm` (每分鐘請求數) 參數來控制對 API 的請求頻率，從源頭上降低觸發 429 錯誤的機率。